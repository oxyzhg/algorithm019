# Week 2

本周由于时间问题，到周三才是学习本周的课程，因此时间并没有很充足。本周的课程设计的相关知识如堆、二叉堆、图等是之前未接触过的数据结构，学起来感到了一些吃力，因此本周是看完第一遍视频快速浏览大致有个印象后，回头来看第二遍才作笔记，以加深印象。

## 哈希表、映射集合

本周由于时间问题，到周三才是学习本周的课程，因此时间并没有很充足。本周的课程设计的相关知识如堆、二叉堆、图等是之前未接触过的数据结构，学起来感到了一些吃力，因此本周是看完第一遍视频快速浏览大致有个印象后，回头来看第二遍才作笔记，以加深印象。

### Hash table

哈希表（Hash Table），也叫散列表，是根据**关键码值**（key value）直接进行访问的数据结构。

他通过把关键码值映射到表中的一个位置来访问记录，以加快查找的速度。这个映射函数成为散列函数（Hash Function），存放记录的表称为哈希表。

应用实例：电话号码簿、用户信息表、缓存（LRU Cache）、键值对存储（Redis）

哈希碰撞，**拉链式解决冲突法**，存储在同一个位置的值，拉出一个链表，依次存储，值比较少的时候，查询时间复杂度是 O(1)，如果链表较长，查询时间会退化成 O(n)。设计好的话，每个位置对应一个值，是完美哈希。

在实际工程开发中，经常用到的是 Set, Map 结构，这两种数据结构在 ES6 中已经实现。详细查看 MDN [Set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set), [Map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map) 相关介绍。这部分内容接触的较少，在 JavaScript 中仅限使用，但对于真实的逻辑实现，并不了熟悉。

## 树、二叉树、二叉搜索树

从链表开始引申，如果每个节点的下一个节点，next 不只是一个值，而是多个值，那么这个结构就是树。

### 二叉树

二叉树用的比较多，它有左子节点和右子节点。

二叉树的结构：

```javascript
class TreeNode {
  constructor(val, left, right) {
    this.val = val === undefined ? 0 : val;
    this.left = left === undefined ? null : left;
    this.right = right === undefined ? null : right;
  }
}
```

二叉树的遍历：

- 前序（Pre-order）遍历：根-左-右
- 中序（In-order）遍历：左-根-右
- 后序（Post-order）遍历：左-右-根

### 二叉搜索树 (Binary Search Tree)

二叉搜索树，也叫二叉排序树，是指一棵空树或符合以下条件的树：

- 左子树上**所有节点**的值均小于它根节点的值
- 右子树上**所有节点**的值均小于它根节点的值
- 以此类推，左右子树也分别是二叉搜索树（这就是重复性）

中序遍历升序排列。

二叉树的大多数面试题都是递归实现。这应该是符合树的特点：有重复性，有递归终止条件。

## 堆和二叉堆、图

在上节中，学习到了数据结构-堆，这部分内容之前有听说过，但是没有详细接触过原理，学完后对堆这种数据结构有了一定的认识，处理 TopK 相关问题也有了思路。【这里还需要手动实现下二叉堆】

本节课学习数据结构-图项内容，会有点陌生，即便是在刷算法题中，也较少出现这方面的题目。

### 数据结构-堆 Heap

Heap：可以快速找到一堆数中的最大值和最小值的数据结构。

通常将根节点最大的堆叫大根堆或大顶堆，将根节点最小的堆叫小根堆或小顶堆。常见的堆是二叉堆、斐波那契堆。

假设是大根堆，常见的操作（API）：

- find-max: O(1)
- delete-max: O(logN)
- insert: O(logN) / O(1)

二叉堆性质：

通过完全二叉树实现，二叉堆满足以下性质：

- 是一棵完全树
- 树中的任意节点的值总是大于等于其子节点的值

疑问：二叉树的时间复杂度为什么一直是跟 log 有关系的，怎么用数学证明???

二叉堆 javascript 实现已经完成。

### 数据结构-图 Graph

首先什么是图？有点有边。
![image.png](https://cdn.nlark.com/yuque/0/2020/png/116852/1605426572410-2083b831-5fd6-48d6-a259-4600e3b854b7.png#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&name=image.png&originHeight=323&originWidth=1046&size=156750&status=done&style=none&width=523)

图的属性：**Graph(V, E)**

**V - vertex：点**

1. 度 - 入度和出度
1. 点与点之间，连通与否

**E - edge：边**

1. 有向和无向（单行线）
1. 权重（边长）

图的表示方法：

1. 邻接矩阵
1. 邻接表

思考题：有向有权图（邻接矩阵）

|     | 0   | 1   | 2   | 3   | 4   |
| --- | --- | --- | --- | --- | --- |
| 0   | 0   | 210 | 0   | 0   | 0   |
| 1   | 0   | 0   | 0   | 190 | 0   |
| 2   | 0   | 60  | 0   | 130 | 0   |
| 3   | 450 | 0   | 0   | 0   | 0   |
| 4   | 0   | 0   | 200 | 0   | 0   |

实现步骤：

1. 先把对角线，即 (0,0), (1,1) ... 等坐标标记为 0
1. 横向从 0 开始，有向边有：0-1, 1-3, 2-1, 2-3, 3-0, 4-2 其余是无向边
1. 将有向边替换权重，即如上图
1. 最后将无向边填充 0

基于图常见的算法：（面试题考的比较少，先熟悉下）

## 学习总结

本周学习的哈希和树相关的内容是相对比较熟悉的，但涉及堆和图相关的内容就感到陌生，之前接触的比较少。本次仿照课上手写实现了 javascript BinaryHeap，加深印象。

作业题中，[丑数](https://leetcode-cn.com/problems/chou-shu-lcof/), [最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/) 使用堆实现方法难理解，可以再详细讲一下。
